# [백준] #15683. 감시

>[문제]: https://www.acmicpc.net/problem/15683
>
>| 시간 제한 | 메모리 제한 | 제출  | 정답 | 맞은 사람 | 정답 비율 |
>| :-------- | :---------- | :---- | :--- | :-------- | :-------- |
>| 1 초      | 512 MB      | 14863 | 6413 | 3768      | 39.672%   |
>
>- 메모리: 1988KB, 시간: 40ms, 코드 길이 2210B
>- 풀이시간: 1시간 40분
>- 제출회차: 2회차



<img src="/Users/DaeHyeon/Library/Application Support/typora-user-images/스크린샷 2020-03-04 오후 3.27.52.png" alt="스크린샷 2020-03-04 오후 3.27.52" style="zoom:50%;" />

위와 같이 총 감시카메라의 종류는 5개이며 이들은 회전이 가능하다. 따라서 5 * 4의 배열이 생기는데 여러방향을 확인하는 감시카메라의 경우 예를 들어 2번의 경우 좌,우가 한 배열 /  상,하가 한 배열에 들어가야 한다. 따라서 대충 3차원의 배열이 생성된다.

또한, 배열의 크기가 각기 다르다. 어떤 카메라는 방향이 2개가 들어가고 어떤 카메라는 3개가 들어간다. 따라서 3차원 vector를 통해 이를 모두 반영시켜주었다.

1. 1번 인덱스 = 카메라 종류
2. 2번 인덱스 = 카메라 방향
3. 3번 인덱스 = 해당 카메라 종류 & 방향일 떄 확인해야 할 dir (dx[],dy[])

***아래 코드를 통해 3차원 vector 생성방법을 숙지해두자!!!***

- 이를 이용해 카메라가 설치된 각 노드의 2번인덱스를 바꿔가며  DFS탐색한다. 

- 이는 카메라 종류와 카메라 방향이 정해진 상태이다. 
- 이 때 해당 케이스에 모든 3번인덱스(확인해야 할 방향)을 BFS탐색을한다.
- ***이 때, 방문을 체크, 초기화해야되는데 방문했던 지점을 또 방문할 수도 있다. 이 때 초기화할 때 false로 하면 전에 방문했던 것까지 초기화시킨다. 따라서 1,2,3 숫자로 체크한다.***



``` c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
#define MAX 9

int n,m;
int mymap[MAX][MAX];
int visited[MAX][MAX]={0,};
int dx[4]={-1,0,1,0}; //상우하좌
int dy[4]={0,1,0,-1};
int finishidx=0;
int ans=987987987;

vector<vector<int>> cctv[6]; // 3차원벡터
vector <pair<int,int>> nodes;

class node{
public:
    int x;
    int y;
    int dir;
};

bool range(int x,int y){
    return 0<= x && x<n && 0<=y && y<m;
}

void makevector(){
    cctv[1]={vector<int>({0}),
        vector<int>({1}),
        vector<int>({2}),
        vector<int>({3})};
    cctv[2]={vector<int>({0,2}),
        vector<int>({1,3})};
    cctv[3]={vector<int>({0,1}),
        vector<int>({1,2}),
        vector<int>({2,3}),
        vector<int>({3,0})};
    cctv[4]={vector<int>({0,1,2}),
        vector<int>({1,2,3}),
        vector<int>({2,3,0}),
        vector<int>({3,0,1})};
    cctv[5]={vector<int>({0,1,2,3})};
}

void cameraRange(int cameraNum,int cameraDir,int x,int y,int flag){ //BFS
    queue <node> q;
    for(int i=0;i<cctv[cameraNum][cameraDir].size();i++){
        q.push({x,y,cctv[cameraNum][cameraDir][i]});
    }
    visited[x][y]+=flag;
    
    while(!q.empty()){
        node current=q.front();
        q.pop();
        current.x+=dx[current.dir];
        current.y+=dy[current.dir];
        if(range(current.x,current.y) && mymap[current.x][current.y]!=6){
            visited[current.x][current.y]+=flag;
            q.push(current);
        }
    }
}

void makeCamera(int idx){ //DFS
    if(finishidx<=idx){
        int sol=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(mymap[i][j]!=6 && visited[i][j]==0)
                    sol++;
            }
        }
        ans=min(ans,sol);
        return;
    }
    
    int cameraNum=mymap[nodes[idx].first][nodes[idx].second];
    for(int i=0;i<cctv[cameraNum].size();i++){
        cameraRange(cameraNum,i,nodes[idx].first,nodes[idx].second,1);
        makeCamera(idx+1);
        cameraRange(cameraNum,i,nodes[idx].first,nodes[idx].second,-1);
    }
}

int main(){        
    makevector();
    cin>>n>>m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>mymap[i][j];
            if(1<=mymap[i][j] && mymap[i][j]<=5)
                nodes.push_back({i,j});
        }
    }
    finishidx=nodes.size();
    makeCamera(0);
    cout<<ans<<"\n";
}

```





















### 풀이

- 모든 노드를 5개의 색종이 중 가능한 색종이들을 모두 넣어 DFS탐색하는 브루트포스 알고리즘을 사용했다. 
- 가능한 색종이는1~5칸 크기의 색종이 중 가능한 큰 크기의 색종이를 구하였고 이 가장 큰 크기부터 1칸짜리 색종이까지만 넣어 DFS 탐색하였다.

### 핵심

***제발!!!! 문제 똑바로 정리하고 넘어가자!!!***

***함수 하나 하나 코드 덩어리 단위로 확인하고 작성하고 확인하고 작성하고 넘어가자!!!!!***

***

``` C++
#include <iostream>
#include <queue>
using namespace std;
const int MAX=10;
const int INF=987987987;

bool mymap[MAX][MAX];
bool visited[MAX][MAX];
int paper[5]={0,};
int ans=INF;
bool range(int x,int y){
    return 0<=x && x<MAX  && 0<=y && y<MAX;
}
bool confirm(){
    for(int i=0;i<MAX;i++){
        for(int j=0;j<MAX;j++){
            if(mymap[i][j]&&!visited[i][j])
                return false;
        }
    }
    return true;
}
int BFS(int x,int y){
    
    for(int i=1;i<5;i++){
        for(int j=0;j<i;j++){ //횟수
            if( !range(x+j,y+i) || visited[x+j][y+i] || !mymap[x+j][y+i] )
                return i-1;
            if( !range(x+i,y+j) || visited[x+i][y+j] ||!mymap[x+i][y+j] )
                return i-1;
        }
        if( !range(x+i,y+i) || visited[x+i][y+i] || !mymap[x+i][y+i] )
            return i-1;
    }
    return 4;
}
void visitecheck(int x,int y, int maxbulk){
    for(int i=0;i<=maxbulk;i++){
        for(int j=0;j<=maxbulk;j++){
            visited[x+i][y+j]=true;
        }
    }
}
void visitecheck2(int x,int y,int maxbulk){
    for(int i=0;i<maxbulk;i++){
        visited[x+maxbulk][y+i]=false;
        visited[x+i][y+maxbulk]=false;
    }
    visited[x+maxbulk][y+maxbulk]=false;
}
void DFS(int x,int y,int sol){
    if(y>=MAX){
        x+=1;
        y=0;
    }
    if(x>=MAX){
        if(confirm())
            ans=min(ans,sol);
        return;
    }
    
    if(mymap[x][y] && !visited[x][y]){
        int maxbulk=BFS(x,y);
        visitecheck(x,y,maxbulk);
        for(int i=maxbulk;i>=0;i--){
            if(paper[i]<5){
                paper[i]++;
                DFS(x,y+i+1,sol+1);
                paper[i]--;
            }
            visitecheck2(x,y,i);
        }
        
    }
    else
        DFS(x,y+1,sol);
}

int main(){
    for(int i=0;i<MAX;i++){
        for(int j=0;j<MAX;j++)
            cin>>mymap[i][j];
    }
    DFS(0,0,0);
    if(ans==INF)
        cout<<-1;
    else
        cout<<ans;
}

```







