 # [백준] #17136번: 색종이 붙이기

> [문제]: https://www.acmicpc.net/problem/17471
>
> 

``` c++
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int MAX =15;
int n;
int people[MAX]={0,};
bool visited[MAX]={false,};
int group_num=0;
int myteam[MAX]={0,};
int totalPeople[MAX]={0,};
int myteam_number[MAX]={0,};
int solution=987987987;
vector <int> mygraph[MAX];


void DFS2(int idx){
    visited[idx]=true;
    totalPeople[myteam[idx]]+=people[idx];
    for(int i=0;i<mygraph[idx].size();i++){
        if(!visited[mygraph[idx][i]] && myteam[idx]==myteam[mygraph[idx][i]]) DFS2(mygraph[idx][i]);
    }
}
void combination(int idx){
    if(idx>n){
        if(myteam_number[1]!=0 && myteam_number[2]!=0){
            totalPeople[1]=0; totalPeople[2]=0;
            fill(visited,visited+MAX,false);
            int confirm=0;
            for(int i=1;i<=n;i++){
                if(!visited[i]){
                    confirm++;
                    DFS2(i);
                }
            }
            if(confirm>2) return;
            solution = min(solution , abs(totalPeople[1]-totalPeople[2])) ;
        }
        return;
    }
    myteam[idx]=1; myteam_number[1]++;
    combination(idx+1);
    myteam[idx]=2; myteam_number[1]--; myteam_number[2]++;
    combination(idx+1);
    myteam_number[2]--;
    
}
void DFS(int idx){
    visited[idx]=true;
    totalPeople[group_num]+=people[idx];
    for(int i=0;i<mygraph[idx].size();i++){
        if(!visited[mygraph[idx][i]]) DFS(mygraph[idx][i]);
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>people[i];
    for(int i=1;i<=n;i++){
        int m;
        cin>>m;
        for(int j=0;j<m;j++){
            int number;
            cin>>number;
            mygraph[i].push_back(number);
        }
    }
    for(int i=1;i<=n;i++){
        if(!visited[i]){
            group_num++;
            DFS(i);
        }
    }
    if(group_num>=3)
        cout<<-1;
    else if(group_num>=2)
        cout<<abs(totalPeople[1]-totalPeople[2]);
    else {
        fill(visited,visited+MAX,false);
        fill(totalPeople,totalPeople+MAX,0);
        combination(1);
        cout<<solution;
    }
}

```



## 코드

``` c++
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
const int MAX=12;

class Edge{
public:
    int x;
    int y;
    int distance;
    bool operator <(const Edge& edge) const{
        return this->distance <edge.distance;
    }
};
int n,m;
int mymap[MAX][MAX];
int group_num=0;
int dx[4]={-1,0,1,0};
int dy[4]={0,-1,0,1};
int mygraph[10][10]={0,};
int solution=0;
int mynode[10]={0,};
vector <Edge> myedge;


//군집나누기 BFS
bool range(int x,int y){
    return 0<=x && x<n && 0<=y && y<m;
}
void BFS(int x,int y){
    queue <pair<int,int>> q;
    q.push({x,y});
    mymap[x][y]=group_num;
    
    while(!q.empty()){
        pair<int,int> current = q.front();
        q.pop();
        for(int i=0;i<4;i++){
            pair<int,int> next = {current.first+dx[i],current.second+dy[i]};
            if(range(next.first,next.second) && mymap[next.first][next.second]==-1){
                mymap[next.first][next.second]=group_num;
                q.push(next);
            }
        }
    }
}

void BFS2(int x,int y,int dir,int group_idx){
    int next_x=x; int next_y=y;
    int distance=0;
    while(1){
        next_x+=dx[dir]; next_y+=dy[dir];
        if(!range(next_x,next_y) || mymap[next_x][next_y]==group_idx) return;
        else if(mymap[next_x][next_y]==0) distance++; //
        else if(distance>1 && (mygraph[group_idx][mymap[next_x][next_y]]==0 || mygraph[group_idx][mymap[next_x][next_y]] > distance)){
            mygraph[group_idx][mymap[next_x][next_y]] = distance;
            mygraph[mymap[next_x][next_y]][group_idx] = distance;
            return;
        }
        else
            return;
    }
}

int getParent(int a){
    if(mynode[a]==a) return a;
    else return getParent(mynode[a]);
}
bool unionParent(int a,int b){
    a=getParent(a);
    b=getParent(b);
    if(a==b) return false;
    
    if(a>b) mynode[b] = a;
    else mynode[a] = b;
    return true;
}

void cruskal(){
    for(int i=1;i<=group_num;i++) mynode[i]=i; // 각 노드에 parent 부여
    for(int i=1;i<=group_num;i++){  // 엣지 vector화
        for(int j=1;j<=group_num;j++){
            if(mygraph[i][j]!=0) myedge.push_back({i,j,mygraph[i][j]});
        }
    }
    sort(myedge.begin(),myedge.end());
    for(int i=0;i<myedge.size();i++){
        if(unionParent(myedge[i].x,myedge[i].y)) solution+=myedge[i].distance;
    }
}

void simulation(){
    //그룹화
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(mymap[i][j]==-1) {
                group_num++;
                BFS(i,j);
            }
        }
    }
    
    //각 군집에서 다른 군집으로 가는 최소 거리 모두 체크
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            for(int k=0;k<4;k++){
                if(mymap[i][j]!=0){
                    BFS2(i,j,k,mymap[i][j]);
                }
            }
        }
    }
    
    cruskal(); // MST
}

int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>mymap[i][j];
            if(mymap[i][j]==1) mymap[i][j]=-1;
        }
    }
    simulation();
    
    int root_node = getParent(1);
    for(int i=2;i<=group_num;i++){
        if(root_node!=getParent(i)){
            solution=-1;
            break;
        }
    }
    
    cout<<solution;
}



```

