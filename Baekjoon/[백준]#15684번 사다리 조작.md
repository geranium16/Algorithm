# [백준] #15684번 사다리 조작

> [문제]: https://www.acmicpc.net/problem/17822
>
> | 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
> | :-------- | :---------- | :--- | :--- | :-------- | :-------- |
> | 1 초      | 512 MB      | 4784 | 1593 | 1052      | 30.273%   |
>
> - 메모리: 1996KB, 시간: 20ms, 코드 길이 3449B
> - 풀이시간: 1시간 
> - 제출회차: 2회차

### 문제

원판을 아래와 같은 방법으로 총 T번 회전시키려고 한다. 원판의 회전 방법은 미리 정해져 있고, i번째 회전할때 사용하는 변수는 xi, di, ki이다.

1. 번호가 xi의 배수인 원판을 di방향으로 ki칸 회전시킨다. di가 0인 경우는 시계 방향, 1인 경우는 반시계 방향이다.
2. 원판에 수가 남아 있으면, 인접하면서 수가 같은 것을 모두 찾는다.
   1. 그러한 수가 있는 경우에는 원판에서 인접하면서 같은 수를 모두 지운다.
   2. 없는 경우에는 원판에 적힌 수의 평균을 구하고, 평균보다 큰 수에서 1을 빼고, 작은 수에는 1을 더한다.

원판을 T번 회전시킨 후 원판에 적힌 수의 합을 구해보자.

### 문제 풀이

 이 문제는 회전, 인접하면서 같은 수 탐색, 같은 수가 없는 경우의 처리 3가지를 구현하면 된다. **사실 구현보다 문제를 얼마나 빠르게 잘 이해하느냐가 핵심이다.**

1. 회전은 m인 컬럼크기를 벗어난 경우 0부터 다시 시작하기 위해 나머지 연산자를 이용하면 쉽게 구현할 수 있다.
2. 인접하면서 같은 수 탐색은 0이 아닌 수 중 같은 수를 BFS로 찾는다. 
3. 같은 수가 없는 경우의 처리를 하기 위해 합계와 총 갯수가 필요한다. 이를 따로 계산할 필요없이 수가 변하는 시점은 2번이다. 이 2번 로직에서 미리 계산을 해준다.



## 코드

``` c++
#include  <iostream>
using namespace std;
const int MAX= 12;
const int MAX2 = 304;
// i번 세로선의 결과가 i번이 나오도록 사다리 게임을 조작하려면, 추가해야하는 가로선 개수의 최소값
// 정답이 3보다 크면 -1출력

int m,n,h;
bool mymap[MAX2][MAX];
int y_init;
bool flag=false;
int solution=-1;

bool DFS(int x,int y,int x_temp,int y_temp){
    if(x>h){
        return y==y_init ? true : false;
    }
    if(mymap[x][y] && y_temp!=y+1)
        return DFS(x,y+1,x,y);
    else if(y>1 && mymap[x][y-1] && y_temp!=y-1)
        return DFS(x,y-1,x,y);
    else
        return DFS(x+1,y,x,y);
}

bool situation(){
    for(int i=1;i<=n;i++){
        y_init=i;
        if(!DFS(1,i,0,0))
            return false;
    }
    return true;
}

void combination(int idx,int cnt,int x,int y){
    if(idx<=cnt){
        if(situation()){
            flag=true;
        }
        return;
    }
    if(y>=n){
        x++;
        y=1;
    }
    if(x>h)
        return;
    
    for(int i=x;i<=h;i++){
        for(int j=y;j<n;j++){
            if(mymap[i][j])
                continue;
            mymap[i][j]=true;
            combination(idx,cnt+1,x,y+1);
            mymap[i][j]=false;
            if(flag)
                return;
        }
    }
}
int main(){
    cin>>n>>m>>h;
    for(int i=0;i<m;i++){
        int a,b;
        cin>>a>>b;
        mymap[a][b]=true;
    }
    for(int i=0;i<=3;i++){
        combination(i,0,1,1);
        if(flag){
            solution=i;
            break;
        }
    }
    cout<<solution;
}

```

