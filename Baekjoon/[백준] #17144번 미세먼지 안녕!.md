 # [백준] #17144번 미세먼지 안녕!

> [문제]: https://www.acmicpc.net/problem/17144
>
> - 풀이시간: 1시간
> - 제출회차: 1회차

### 문제 

드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 좌표 평면의 x축은 → 방향, y축은 ↓ 방향이다.

시작 점, 시작 방향, 세대

1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 0세대 드래곤 커브의 끝 점에 붙인 것이다. 끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다.

즉, K(K > 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점에 붙인 것이다.

크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.

첫째 줄에 드래곤 커브의 개수 N(1 ≤ N ≤ 20)이 주어진다.

둘째 줄부터 N개의 줄에는 드래곤 커브의 정보가 주어진다.

 드래곤 커브의 정보는 네 정수 x, y, d, g로 이루어져 있다. x와 y는 드래곤 커브의 시작 점, d는 시작 방향, g는 세대이다. (0 ≤ x, y ≤ 100, 0 ≤ d ≤ 3, 0 ≤ g ≤ 10)

입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.

방향은 0, 1, 2, 3 중 하나이고, 다음을 의미한다.

- 0: x좌표가 증가하는 방향 (→)
- 1: y좌표가 감소하는 방향 (↑)
- 2: x좌표가 감소하는 방향 (←)
- 3: y좌표가 증가하는 방향 (↓)

첫째 줄에 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 것의 개수를 출력한다.

### 어려웠던 점: 조건이해

>  입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.
>
> 이 조건이 의미하는 바가 정확히 이해하지못했다.
>
> - 입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다의 의미가 세대가 커져도 벗어나지 않게 주어진다는 말인가? 격자 밖으로 벗어날 경우 어떻게 처리한다는 내용이 없으니 이쪽으로 유추하는 편이 가능성이 높을 것이다.
>
> - 드래곤 커브는 서로 겹칠 수 있따.? 겹치면 합쳐지는 것인가? 이경우에 처리 내용이 없다. 따라서 이도 그냥 따로 따로 계쏙 진행하는 편으로 이해하는 것이 맞을 가능성이 높을 것같다.
>
> 근데 아무리 생각해도 조건에 허점이 너무 많다.



가로가 X, 세로가 Y로 나왔다. 이를 내가 원래 사용한대로 (y,x)로 받았다. 이렇게 할 경우 회전 방향이 바뀌는가? 그렇지않다. 도화지를 보고 있다고 가정하면 y,x이든 x,y이든 회전방향은 시계방향으로 똑같다. 또한 0,1,2,3은 (y,x)기준으로 맞춰줬다.



### 풀이

**끝 점을 기준으로 90도 시계 방향 회전** 한다. 즉, 끝점을 컴퍼스로찍고 나머지를 시계방향으로 돌리는 것이다. 결국 현실에선 선을 돌리는 것이지만, 코드로는 점으로 표현해야한다. 그래서 끝점을 기준으로 전부 돌려야하므로 끝점에서부터 시작점까지 따라가봣다. 한 노드씩 따라간다고 생각하면, 끝 점에서 이전 노드를 시계방향으로 돌리면 이 끝 점에서 다음 노드는 끝점에서 이전노드의 방향을 반시계방향으로 돌린 방향으로 이동하며, 다음 노드는 이방향을 가지고 있다. 이 규칙을 가지고 시작노드까지 따라가면 끝점을 계쏙 이동해나가면 전체 커브를 시계방향으로 돌린 것이 만들어지고 이를 코드로 구현하면 된다.



## 코드

``` c++

#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
const int MAX = 52;

int r,c,t;
int mymap[MAX][MAX];
int solution=0;
int dx[4]={-1,0,1,0};
int dy[4]={0,-1,0,1};
pair<int,int> merchine[2];

bool range(int x,int y){
    return 0<=x && x<r && 0<=y && y<c;
}

void diffusion(){
    int temp[MAX][MAX]={0,};
    temp[merchine[0].first][merchine[0].second]=-1;
    temp[merchine[1].first][merchine[1].second]=-1;
    for(int i=0;i<r;i++){
        for(int j=0;j<c;j++){
            if(mymap[i][j]>0){
                vector <pair<int,int>> new_xy;
                for(int k=0;k<4;k++){
                    pair <int,int> next={i+dx[k],j+dy[k]};
                    if(range(next.first,next.second) && mymap[next.first][next.second]>=0)
                        new_xy.push_back(next);
                }
                int var=0;
                for(int k=0;k<new_xy.size();k++){
                    temp[new_xy[k].first][new_xy[k].second]+=mymap[i][j]/5;
                    var+=mymap[i][j]/5;
                }
                temp[i][j] += mymap[i][j]-var; //A-(A/5)*확산 수
            }
        }
    }
    memcpy(mymap,temp,sizeof(mymap));
}
void cleaning(){
    solution-=mymap[merchine[0].first-1][0];
    for(int i=merchine[0].first-1;i>0;i--)
        mymap[i][0]=mymap[i-1][0];
    for(int i=0;i<c-1;i++)
        mymap[0][i]=mymap[0][i+1];
    for(int i=0;i<merchine[0].first;i++)
        mymap[i][c-1]=mymap[i+1][c-1];
    for(int i=c-1;i>1;i--)
        mymap[merchine[0].first][i]=mymap[merchine[0].first][i-1];
    mymap[merchine[0].first][merchine[0].second+1]=0;

    solution-=mymap[merchine[1].first+1][0];
    for(int i=merchine[1].first+1;i<r-1;i++)
        mymap[i][0]=mymap[i+1][0];
    for(int i=0;i<c-1;i++)
        mymap[r-1][i]=mymap[r-1][i+1];
    for(int i=r-1;i>merchine[1].first;i--)
        mymap[i][c-1]=mymap[i-1][c-1];
    for(int i=c-1;i>1;i--)
        mymap[merchine[1].first][i]=mymap[merchine[1].first][i-1];
    mymap[merchine[1].first][merchine[1].second+1]=0;
}

void simulation(int cnt){
    if(cnt>=t)
        return;
    diffusion();
    cleaning();
    simulation(cnt+1);
}

int main(){
    cin>>r>>c>>t;
    for(int i=0;i<r;i++){
        for(int j=0;j<c;j++){
            cin>>mymap[i][j];
            if(mymap[i][j]>0)
                solution+=mymap[i][j];
            else if(mymap[i][j]==-1 && mymap[i-1][j]==-1){
                merchine[0]={i-1,j};
                merchine[1]={i,j};
            }
        }
    }
    simulation(0);
    cout<<solution;
}

```

