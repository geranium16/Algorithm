# [백준] #14502번 연구소

> [문제]: https://www.acmicpc.net/problem/14502
>
> - 풀이시간: 1시간 30분
> - 제출회차: 2회차

### 문제 

- 8개의 톱니, 톱니바퀴 4개,   총 K번 회전 ,시계 or 반시계

- 인접 톱니바퀴와 다르면 반대 방향 회전 및 전파, 같으면 회전 X, 회전 전 기준

- 왼쪽부터  1, 2, 3, 4번
-  반시계방향: -1, 시계방향: 1

- 출력: 총 k번 회전시킨 이후에 네 톱니바퀴의 점수의 합



### 문제 풀이

 회전 전 기준으로 전파 가능 한지 확인하여야 되기 때문에 회전 가능 여부, 방향을 전부 체크한 뒤 회전 시켜야 한다.

따라서 필요한 함수는 **회전 가능, 방향 체크** / **시계, 반시계 방향 회전**

### 놓친 부분 & 오래걸린 이유

- 101010 붙어서 데이터가 주어진 경우 char로 받아야 한다.

- 톱니바퀴 1,2,3,4로 주어지지만 0번 인덱스부터 시작

## 코드

``` c++

/*
 14:10 03:06
 n*m
 세울 수 있는 벽: 3개, 꼭 세워야한다.
 0 빈칸, 1 벽, 2바이러스
 얻을 수 있는 안전 지역 크기의 최대값
 
 브루트 포스
 1. 바이러스 3개 위치 선택 60C3
 -> 콤비네이션
 
 2. 선택을 토대로 바이러스 확산 DFS
 */

#include <iostream>
#include <queue>
#include <cstring>
#include <vector>
using namespace std;
const int MAX=10;


int mymap[MAX][MAX];
int n,m;
int safetyArea=-3;
int sol=0;
vector <pair<int,int>> birus;
bool visited[MAX][MAX];
int dx[4]={-1,0,1,0};
int dy[4]={0,-1,0,1};

bool range(int x,int y){
    return 0<= x && x<n && 0<=y && y<m;
}
int BFS(int x,int y){
    visited[x][y]=true;
    queue <pair<int,int>> q;
    q.push({x,y});
    int num=0;
    while(!q.empty()){
        pair<int,int> current=q.front();
        q.pop();
        for(int i=0;i<4;i++){
            pair<int,int> next = {current.first+dx[i],current.second+dy[i]};
            if(range(next.first,next.second) && mymap[next.first][next.second]==0 && !visited[next.first][next.second]){
                visited[next.first][next.second]=true;
                num++;
                q.push(next);
            }
        }
    }
    return num;
}
void selection(int cnt,int x,int y){
    if(cnt>=3){
        int ans=safetyArea;
        memset(visited,false,sizeof(visited));
        for(int i=0;i<birus.size();i++)
            ans-=BFS(birus[i].first,birus[i].second);
        sol = ans> sol ? ans : sol;
        return;
    }
    if(y>=m){
        if(x>=n)
            return;
        y=0; x++;
    }
    for(int j=y;j<m;j++){
        if(mymap[x][j]==0){
            mymap[x][j]=1;
            selection(cnt+1,x,j+1);
            mymap[x][j]=0;
        }
    }
    for(int i=x+1;i<n;i++){
        for(int j=0;j<m;j++){
            if(mymap[i][j]==0){
                mymap[i][j]=1;
                selection(cnt+1,i,j+1);
                mymap[i][j]=0;
            }
        }
    }
    
}
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>mymap[i][j];
            if(mymap[i][j]==0)
                safetyArea++;
            else if(mymap[i][j]==2)
                birus.push_back({i,j});
        }
    }
    selection(0,0,0);
    cout<<sol;
}

```

