### 정리



[5/6] 톱니바퀴:  시뮬레이션, 51.21%, 1시간, 성공

[5/6] 연구소: 시뮬레이션, 54.668%, 1시간 30분, 실패

[5/6] 스타트와링크: 시뮬레시이션, 49.512%, 30분, 성공

[5/7] 드래곤커브: 시뮬레이션, 51.664%, 1시간, 성공 -> 문제에 조건이 너무 부실한거같은디?

[5/10] 미세먼지 안녕!: 시뮬레이션 53.749%, 1시간 50분, 성공 -> 회전 인덱스관리 !!!!! 회전연습

[5/14] 게리멘더링2: 시뮬레이션 52.726% 2시간, 성공 -> 문제이해

[5/16] 경사로: 시뮬레이션 52.990% 2시간, 실패 -> 문제이해, -인덱스 이용하는 습관 *** 다시 보기

[5/16] 큐빙: 시뮬레이션 35.502% 2시간,성공 ->하드코딩

### 1. 설계의 완벽성 높이기 

- 완벽히, 완벽 이해하고 예제도 완벽히 이해하고!!!!

- 의미 없는 조건은 없다. 의미없어 보일 경우에도 해석!!!! 
- 전체플로우, 함수 역활 정의하고 시작해야 한다.!!!
- 조건 하나 빼먹는다!!!
- 시계방향 및 반시계방향을 위한 인덱스 정리같은 복잡한 식 노트에 적기!!!!

###  2. 실수줄이기

- 101010 띄어쓰기 없이 주어진 경우 char로 받아야 한다.
- 복붙 의심!!!
- 초기화!!!!!



### 3. 문법

- pow 

``` c++
#include <cmath>
pow(2,0); // 2^0
pow(2,i-1); //2^(i-1)
```



- sort 사용자 정의 함수

``` c++
bool compare(const pair<int,int> &a, const pair<int,int> &b){

  if(a.second != b.second)
  	return a.second<b.second;

  else
    return a.first<b.first;

}
```



- 이차원 벡터 사용법

``` c++
vector <vector<pair<int,int>>> dist;
for(int i=0;i<house.size();i++){
  vector<pair<int,int>> elem;
  dist.push_back(elem);
}
```



- 맵 ( 이중배열 ) combination

: 전 위치에서 같은 행만 전 열+1부터 시작해야하고 그 다음 행부터는 0부터 시작해야 한다. 다른 포문으로 처리해야 한다.

``` c++
void selection(int cnt,int x,int y){
    if(cnt>=3)
        return;
    if(y>=m){
      	y=0; x++;
        if(x>=n)
            return;
    }
    
    for(int j=y;j<m;j++){
        if(mymap[x][j]==0){
            mymap[x][j]=1;
            selection(cnt+1,x,j+1);
            mymap[x][j]=0;
        }
    }
  
    for(int i=x+1;i<n;i++){
        for(int j=0;j<m;j++){
            if(mymap[i][j]==0){
                mymap[i][j]=1;
                selection(cnt+1,i,j+1);
                mymap[i][j]=0;
            }
        }
    }
}
```



- 매개변수로 이차원배열 포인터로 받기

**void** rotation(**char** (*mymap)[3])

reverse_rotation(B);

