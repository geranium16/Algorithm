

### 정리



[5/6] 톱니바퀴:  시뮬레이션, 51.21%, 1시간, 성공

[5/6] 연구소: 시뮬레이션, 54.668%, 1시간 30분, 실패

[5/6] 스타트와링크: 시뮬레시이션, 49.512%, 30분, 성공

[5/7] 드래곤커브: 시뮬레이션, 51.664%, 1시간, 성공 -> 문제에 조건이 너무 부실한거같은디?

[5/10] 미세먼지 안녕!: 시뮬레이션 53.749%, 1시간 50분, 성공 -> 회전 인덱스관리 !!!!! 회전연습

[5/14] 게리멘더링2: 시뮬레이션 52.726% 2시간, 성공 -> 문제이해

[5/16] 경사로: 시뮬레이션 52.990% 2시간, 실패 -> 문제이해, -인덱스 이용하는 습관 *** 다시 보기

[5/16] 큐빙: 시뮬레이션 35.502% 2시간,성공 ->하드코딩

[5/17] 연산자 끼워넣기: 시뮬레이션 / 50.314% / 성공 / 총시간(30) / 설계(6:30) /  코딩&디버깅(23:30) ->초기화

### 1. 설계의 완벽성 높이기 

- **완벽히, 완벽 이해하고 예제도 완벽히 이해하고!!!!**
- 의미 없는 조건은 없다. 의미없어 보일 경우에도 해석!!!! 
- 전체플로우, 함수 역활 정의하고 시작해야 한다.!!!
- **조건 하나 빼먹는다!!!**
- **시계방향 및 반시계방향을 위한 인덱스 정리같은 복잡한 식 노트에 적기!!!!**
- 규칙이 복잡할 경우 하드코딩!!!!

***결국 초반 시간이 더 걸릴 순 있어도 조건, 헷갈리는 것 및 복잡한 식같은 것은 노트에 적고 보면서 하자***

###  2. 실수줄이기

- 101010 띄어쓰기 없이 주어진 경우 char로 받아야 한다.
- 복붙 의심!!!
- 초기화!!!!!

### 3. 문법



***#include <vector>***

``` c++
v.insert(2,3,4); //2번째 위치에 3개의 4값을 삽입 (뒤엣놈은 밀림)
v.insert(2,3); // 2번째 위치에 3삽입
v.erase(iter); // iter가 가르리키는 원소제거
v.erase(v.begin()+1,v.end());

vector <int> temp;
temp.push_back(1);temp.push_back(2);temp.push_back(3);
temp.erase(temp.begin()+1);
for(int i=0;i<temp.size();i++)
	cout<<temp[i]; //1,3출력

vector <vector<pair<int,int>>> dist;
for(int i=0;i<house.size();i++){
  vector<pair<int,int>> elem;
  dist.push_back(elem);
}

```



***#include <algorithm>***

****

- sort

``` c++
bool compare(const pair<int,int> &a, const pair<int,int> &b){
  if(a.second != b.second)
  	return a.second<b.second;
  else
    return a.first<b.first;
}
//같은 숫자 안정성 보장x : {5,2,3,2!,6,2@} -> {2!,2@,2,3,5,6}
sort(vec.begin(),vec.end());
sort(arr1,arr1+n);

//같은 숫자 안정성 보장:원래순서대로 :{5,2,3,2!,6,2@} -> {2,2!,2@,3,5,6} 
stable_sort(vec.begin(),vec.end());
```



- find()

``` c++
//주소를 반환한다. *주소하면 값을 찾을 수 있지만 이 find를 쓰는 경우는 8을 찾기위해서이며
//이 find()를 활용할 수 있는 부분은 있냐 없냐 or 위치찾기이다.
int a[10] = {1, 4, 7, 10, 2, 5, 8, 3, 6, 9};    
int *p, *q;
 
p = find(a, a+10, 8);
if(p == a+10) cout << "값 8을 찾지 못했습니다. ㅠㅠ" << endl;
else cout << "값 8을 a[" << p-a << "]에서 찾았습니다." << endl; //p위치-시작위치 = 8의 인덱스 찾을 수 있다.
       
q = find(a+3, a+8, 4);
if(q == a+8) cout << "값 4를 찾지 못했습니다. ㅠㅠ" << endl;
else cout << "값 4를 a[" << q-a << "]에서 찾았습니다." << endl;
```



- max_element,min_element

``` c++
//최대값 주소 반환 (* 붙여서 값 확인가능) max(1,2)가 아닌 여러개를 비교해야 할 때 사용
int arr[5]={3,5,2,1,4};
cout<<*max_element(arr,arr+5); //5
cout <<*min_element(arr,arr+5); //5
```



- count()

``` c++
//만족하는 값의 개수를 세는 함수
bool greaterThan4(int n){
return (n > 4);
}
int a[10] = {1, 3, 2, 4, 5, 2, 4, 2, 8, 6};
count(a, a+10, 2) //3개
count_if(a,a+10,greaterThan4); //3개
```



- binary_search

``` c++
// 정렬가정하 이진 탐색 
int arr[10]={1,2,3,4,5,6,7,8,9,10};
if(binary_search(a,a+10,3)); // true
if(binary_search(a,a+10,13)); // false
```



- lower_bound, high_bound

``` c++
//기본적으로 정렬가정하 이진탐색  
//리턴값은 원소의 주소값이다. 
//주어진값보다 크거나 같으면서 제일 작은 값
*lower_bound(arr,arr+10,6) //6
//주어진값보다 크면서 제일 작은 값 , 차이는 같은 값을 포함하냐 안하냐
*lower_bound(arr,arr+10,6) //7
```



- next_permutation

``` c++
//정렬이 되어 잇어야한다.
// 1,2,3,4의 배열이 있을 때 다음 순열인 1,2,4,3로 바뀌고 true 반환
int arr[10]={1,2,3,4,5,6,7,8,9,10};
do{ //do가 먼저 실행되고 while 검사
  for(int i=0;i<10;i++)
    cout<<arr[i];
}while(next_permutation(arr,arr+10));
```

- map, set??



***#include <cmath>***

``` c++
#include <cmath>
abs(-123); //123
max(1.1,1.02) //1.1
min(1.1,1.02) //1.02
ceil(3.14); //4 올림, double반환
floor(1.89); //1 내림, double반환
pow(2,0); // 2^0
pow(2,i-1); //2^(i-1)
sqrt(16); //4
```



***#include <cstring>***

```;c++
memset(check, false, sizeof(check));
memcpy(check,check2,sizeof(check));
```



***#include <bitset>***

``` c++
int main(){
  bitset<10000> a(76),b(64);
  cout<< a&b << "\n";
}
```



- 맵 ( 이중배열 ) combination

: 전 위치에서 같은 행만 전 열+1부터 시작해야하고 그 다음 행부터는 0부터 시작해야 한다. 다른 포문으로 처리해야 한다.

``` c++
void selection(int cnt,int x,int y){
    if(cnt>=3)
        return;
    if(y>=m){
      	y=0; x++;
        if(x>=n)
            return;
    }
    
    for(int j=y;j<m;j++){
        if(mymap[x][j]==0){
            mymap[x][j]=1;
            selection(cnt+1,x,j+1);
            mymap[x][j]=0;
        }
    }
  
    for(int i=x+1;i<n;i++){
        for(int j=0;j<m;j++){
            if(mymap[i][j]==0){
                mymap[i][j]=1;
                selection(cnt+1,i,j+1);
                mymap[i][j]=0;
            }
        }
    }
}
```



- 매개변수로 이차원배열 포인터로 받기

**void** rotation(**char** (*mymap)[3])

reverse_rotation(B);



매개변수

배열 : 주소복사

vector : 값복사

class : 값복사 (참조하고 싶을경우 &)



